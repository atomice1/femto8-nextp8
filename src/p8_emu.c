/*
 * p8_emu.c
 *
 *  Created on: Dec 13, 2023
 *      Author: bbaker
 */

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#if defined(_WIN32)
#include <direct.h>   // _mkdir
#define MKDIR(p) _mkdir(p)
#else
#include <sys/types.h>
#include <sys/stat.h> // mkdir
#define MKDIR(p) mkdir((p), 0777)
#endif
#include <unistd.h>
#include <math.h>
#include <assert.h>
#ifdef OS_FREERTOS
#include <FreeRTOS.h>
#include <task.h>
#include "retro_heap.h"
#include "ble_controller.h"
#endif
#include "p8_audio.h"
#include "p8_compat.h"
#include "p8_emu.h"
#include "p8_lua.h"
#include "p8_lua_helper.h"
#include "p8_overlay_helper.h"
#include "p8_parser.h"
#include "p8_pause_menu.h"

#if defined(SDL)
#include "SDL.h"
#elif defined(__DA1470x__)
#include "gdi.h"
#elif defined(NEXTP8)
#include "nextp8.h"
#include "postcodes.h"
#endif

#if defined(SDL)
// ARGB
uint32_t m_colors[32] = {
    0x00000000, 0x001d2b53, 0x007e2553, 0x00008751, 0x00ab5236, 0x005f574f, 0x00c2c3c7, 0x00fff1e8,
    0x00ff004d, 0x00ffa300, 0x00ffec27, 0x0000e436, 0x0029adff, 0x0083769c, 0x00ff77a8, 0x00ffccaa,
    0x00291814, 0x00111D35, 0x00422136, 0x00125359, 0x00742F29, 0x0049333B, 0x00A28879, 0x00F3EF7D,
    0x00BE1250, 0x00FF6C24, 0x00A8E72E, 0x0000B54E, 0x00065AB5, 0x00754665, 0x00FF6E59, 0x00FF9D81};
#else
// RGB565
uint16_t m_colors[32] = {
    0x0000, 0x194a, 0x792a, 0x042a, 0xaa86, 0x5aa9, 0xc618, 0xff9d, 0xf809, 0xfd00, 0xff64, 0x0726, 0x2d7f, 0x83b3, 0xfbb5, 0xfe75,
    0x28c2, 0x10e6, 0x4106, 0x128b, 0x7165, 0x4987, 0xa44f, 0xf76f, 0xb88a, 0xfb64, 0xaf25, 0x05a9, 0x02d6, 0x722c, 0xfb6b, 0xfcf0};
#endif

// Convert 8-bit screen palette value to 5-bit color index.
static inline int color_index(uint8_t c)
{
    return ((c >> 3) & 0x10) | (c & 0xf);
}

static int p8_init_lcd(void);
static void p8_main_loop();
static void p8_show_compatibility_error(int severity);

uint8_t *m_memory = NULL;
uint8_t *m_cart_memory = NULL;

uint8_t *m_overlay_memory = NULL;

unsigned m_fps = 30;
unsigned m_actual_fps = 0;
unsigned m_frames = 0;

p8_clock_t m_start_time;

jmp_buf jmpbuf_restart;
static bool restart;

static jmp_buf jmpbuf_load;
bool m_load_available = false;
static bool load_requested = false;
static char *load_filename = NULL;
static char *load_param = NULL;
char *current_cart_dir = NULL;

static bool skip_compat_check = false;
static bool skip_main_loop_if_no_callbacks = false;

const char *m_param_string = "";

#ifdef SDL
SDL_Surface *m_screen = NULL;
SDL_Surface *m_output = NULL;
SDL_PixelFormat *m_format = NULL;
#endif
#ifdef OS_FREERTOS
SemaphoreHandle_t m_drawSemaphore;
#endif

int16_t m_mouse_x, m_mouse_y;
int16_t mouse_x4, mouse_y4;
int16_t m_mouse_xrel, m_mouse_yrel;
uint8_t m_mouse_buttons;
int8_t m_mouse_wheel;
uint8_t m_keypress;
bool m_scancodes[NUM_SCANCODES];

uint16_t m_buttons[PLAYER_COUNT];
uint16_t m_buttonsp[PLAYER_COUNT];
uint16_t m_button_first_repeat[PLAYER_COUNT];
unsigned m_button_down_time[PLAYER_COUNT][BUTTON_INTERNAL_COUNT];

static bool m_prev_pointer_lock;

static FILE *cartdata = NULL;
static bool cartdata_needs_flush = false;

static int m_initialized = 0;

#ifdef NEXTP8
static int vfrontreq = 0;
static int16_t mouse_x_accum_prev = 0;
static int16_t mouse_y_accum_prev = 0;
static int16_t mouse_z_accum_prev = 0;
#endif

const uint8_t turtle_icon[32] = {
    0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11,
    0x11, 0x44, 0x11, 0xbb,
    0x41, 0x44, 0xb4, 0x3b,
    0x93, 0x99, 0x19, 0x11,
    0xb1, 0xbb, 0xbb, 0x11,
    0x1b, 0x11, 0xb1, 0x11,
    0x11, 0x11, 0x11, 0x11,
};

const uint8_t disk_icon[32] = {
    0xc1, 0x66, 0x61, 0x11,
    0xc1, 0x66, 0x61, 0x1c,
    0xc1, 0xcc, 0xcc, 0x1c,
    0xc1, 0x77, 0x77, 0x1c,
    0xc1, 0x77, 0x77, 0x1c,
    0xc1, 0x77, 0x77, 0x1c,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
};

static p8_clock_t p8_clock(void)
{
#if defined(OS_FREERTOS)
    return xTaskGetTickCount();
#elif defined(NEXTP8)
    return *(volatile uint64_t *)_UTIMER_1MHZ;
#else
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * UINT64_C(1000000) + ts.tv_nsec / UINT64_C(1000);
#endif
}

static unsigned p8_clock_ms(p8_clock_t clocks)
{
#if defined(OS_FREERTOS)
    return clocks * portTICK_PERIOD_MS;
#else
    return clocks / UINT64_C(1000);
#endif
}

static p8_clock_t p8_clock_delta(p8_clock_t start, p8_clock_t end)
{
    return end - start;
}

static void p8_sleep(unsigned ms)
{
#ifdef OS_FREERTOS
    vTaskDelay(pdMS_TO_TICKS(ms));
#else
    usleep(ms * 1000);
#endif
}

int p8_init()
{
    assert(!m_initialized);

    srand((unsigned int)time(NULL));

#ifdef SDL
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0)
    {
        printf("Error on SDL_Init().\n");
        return 1;
    }

    SDL_ShowCursor(0);
    SDL_EnableKeyRepeat(0, 0);

    m_screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_HWSURFACE);
    m_format = m_screen->format;

    m_output = SDL_CreateRGBSurface(0, P8_WIDTH, P8_HEIGHT, 32, m_format->Rmask, m_format->Gmask, m_format->Bmask, m_format->Amask);

    SDL_WM_SetCaption("femto-8", NULL);
#endif
#ifdef OS_FREERTOS
    m_drawSemaphore = xSemaphoreCreateBinary();

    xSemaphoreGive(m_drawSemaphore);
#endif
#ifndef OS_FREERTOS
    m_memory = (uint8_t *)malloc(MEMORY_SIZE);
    m_cart_memory = (uint8_t *)malloc(CART_MEMORY_SIZE);
    m_overlay_memory = (uint8_t *)malloc(MEMORY_SCREEN_SIZE);
#else
    m_memory = (uint8_t *)rh_malloc(MEMORY_SIZE);
    m_cart_memory = (uint8_t *)rh_malloc(CART_MEMORY_SIZE);
    m_overlay_memory = (uint8_t *)rh_malloc(MEMORY_SCREEN_SIZE);
#endif

    memset(m_memory, 0, MEMORY_SIZE);
    memset(m_cart_memory, 0, CART_MEMORY_SIZE);
    memset(m_overlay_memory, (OVERLAY_TRANSPARENT_COLOR << 4) | OVERLAY_TRANSPARENT_COLOR, MEMORY_SCREEN_SIZE);

#ifdef ENABLE_AUDIO
    audio_init();
#endif

    p8_init_lcd();

    for (unsigned p=0;p<2;++p) {
        for (unsigned i=0;i<BUTTON_INTERNAL_COUNT;++i) {
            m_button_down_time[p][i] = UINT_MAX;
        }
    }

#ifdef NEXTP8
    memset((void *)_KEYBOARD_MATRIX_LATCHED, 0xff, 32);
    *(volatile uint8_t *)_JOYSTICK0_LATCHED = 0xff;
    *(volatile uint8_t *)_JOYSTICK1_LATCHED = 0xff;
    *(volatile uint8_t *)_MOUSE_BUTTONS_LATCHED = 0xff;
#endif

    m_initialized = 1;

    return 0;
}

static int p8_init_lcd(void)
{
#if defined(NEXTP8)
    uint8_t overlay_ctrl_reg = _OVERLAY_ENABLE_BIT | (OVERLAY_TRANSPARENT_COLOR & _OVERLAY_TRANSPARENT_MASK);
    *(volatile uint8_t *)_OVERLAY_CONTROL = overlay_ctrl_reg;
    vfrontreq = *(volatile uint8_t *)_VFRONT;
#elif defined(__DA1470x__)
    gdi_set_layer_start(HW_LCDC_LAYER_0, 0, 0);

    gdi_set_layer_enable(HW_LCDC_LAYER_0, true);

    uint16_t *fb = (uint16_t *)gdi_get_frame_buffer_addr(HW_LCDC_LAYER_0);

    gdi_set_layer_src(HW_LCDC_LAYER_0, fb, SCREEN_WIDTH, SCREEN_HEIGHT, GDI_FORMAT_RGB565);
#endif

    return 0;
}

static void p8_init_common(const char *file_name, const char *lua_script)
{
    if (lua_script == NULL) {
        if (file_name) fprintf(stderr, "%s: ", file_name);
        fprintf(stderr, "invalid cart\n");
        exit(1);
    }

    if (setjmp(jmpbuf_restart)) {
        if (!restart)
            return;
    }

    if (!restart && !skip_compat_check) {
        int ret = check_compatibility(file_name, lua_script);
        if (ret != COMPAT_OK)
            p8_show_compatibility_error(ret);
        if (ret == COMPAT_NONE)
            return;
    }
    restart = false;

    memcpy(m_memory, m_cart_memory, CART_MEMORY_SIZE);

    m_frames = 0;

    p8_reset();
    clear_screen(0);
    p8_show_disk_icon(false);

    p8_update_input();

    lua_init_script(lua_script);

    lua_init();

    if (!skip_main_loop_if_no_callbacks || lua_has_main_loop_callbacks())
        p8_main_loop();
}

int p8_init_file_with_param(const char *file_name, const char *param)
{
    if (!m_initialized)
        p8_init();

    m_param_string = param ? param : "";
    m_load_available = true;

    const char *lua_script = NULL;
    uint8_t *file_buffer = NULL;

    if (setjmp(jmpbuf_load)) {
        load_requested = false;

#ifdef OS_FREERTOS
        rh_free(file_buffer);
#else
        free(file_buffer);
#endif

        lua_shutdown_api();

        m_param_string = load_param ? load_param : "";
        file_name = load_filename;
    }

    if (current_cart_dir) {
#ifdef OS_FREERTOS
        rh_free(current_cart_dir);
#else
        free(current_cart_dir);
#endif
    }

    const char *last_slash = strrchr(file_name, '/');
    if (last_slash) {
        size_t dir_len = last_slash - file_name;
#ifdef OS_FREERTOS
        current_cart_dir = rh_malloc(dir_len + 1);
#else
        current_cart_dir = malloc(dir_len + 1);
#endif
        memcpy(current_cart_dir, file_name, dir_len);
        current_cart_dir[dir_len] = '\0';
    } else {
        current_cart_dir = strdup(".");
    }

    p8_show_disk_icon(true);
    lua_load_api();

    printf("Loading %s\n", file_name);
    parse_cart_file(file_name, m_cart_memory, &lua_script, &file_buffer, NULL);

    p8_init_common(file_name, lua_script);

#ifdef OS_FREERTOS
    rh_free(file_buffer);
#else
    free(file_buffer);
#endif

    return 0;
}

int p8_init_ram(uint8_t *buffer, int size)
{
    if (!m_initialized)
        p8_init();

    p8_show_disk_icon(true);
    lua_load_api();

    const char *lua_script = NULL;
    uint8_t *decompression_buffer = NULL;

    parse_cart_ram(buffer, size, m_cart_memory, &lua_script, &decompression_buffer);

    p8_init_common(NULL, lua_script);

#ifdef OS_FREERTOS
    rh_free(decompression_buffer);
#else
    free(decompression_buffer);
#endif

    return 0;
}

int p8_shutdown()
{
#ifdef ENABLE_AUDIO
    audio_close();
#endif

    lua_shutdown_api();

    p8_close_cartdata();

#ifdef SDL
    SDL_FreeSurface(m_output);
    SDL_FreeSurface(m_screen);
    SDL_Quit();
#endif
#ifdef OS_FREERTOS
    rh_free(m_cart_memory);
    rh_free(m_memory);
    rh_free(m_overlay_memory);
#else
    free(m_cart_memory);
    free(m_memory);
    free(m_overlay_memory);
#endif

    m_initialized = 0;

    return 0;
}

#ifdef SDL
void p8_render()
{
    uint32_t *output = m_output->pixels;

    for (int y = 0; y < P8_HEIGHT; y++)
    {
        for (int x = 0; x < P8_WIDTH; x++)
        {
            int screen_offset = (m_memory[MEMORY_SCREEN_PHYS] << 8) + (x >> 1) + y * 64;
            uint8_t value = m_memory[screen_offset];
            uint8_t index = color_get(PALTYPE_SCREEN, IS_EVEN(x) ? value & 0xF : value >> 4);
            uint32_t color = m_colors[color_index(index)];

            output[x + (y * P8_WIDTH)] = color;
        }
    }

    uint8_t *overlay_mem = m_overlay_memory;

    for (int y = 0; y < P8_HEIGHT; y++)
    {
        for (int x = 0; x < P8_WIDTH; x++)
        {
            int overlay_offset = (x >> 1) + y * 64;
            uint8_t value = overlay_mem[overlay_offset];
            uint8_t pixel_color = IS_EVEN(x) ? (value & 0xF) : (value >> 4);

            if (pixel_color != OVERLAY_TRANSPARENT_COLOR)
            {
                uint32_t color = m_colors[color_index(pixel_color)];
                output[x + (y * P8_WIDTH)] = color;
            }
        }
    }

    SDL_Rect rect = {0, 0, SCREEN_WIDTH, SCREEN_HEIGHT};
    // SDL_BlitSurface(m_output, NULL, m_screen, &rect);
    SDL_SoftStretch(m_output, NULL, m_screen, &rect);
    SDL_Flip(m_screen);
}
#elif defined(__DA1470x__)

#ifdef OS_FREERTOS
void draw_complete(bool underflow, void *user_data)
{
    xSemaphoreGive(m_drawSemaphore);
}
#endif

void p8_render()
{
#ifdef OS_FREERTOS
    if (xSemaphoreTake(m_drawSemaphore, portMAX_DELAY) != pdTRUE)
        return;
#endif

    sprintf(m_str_buffer, "%d", (int)m_actual_fps);
    draw_text(m_str_buffer, 0, 0, 1);

    uint16_t *output = gdi_get_frame_buffer_addr(HW_LCDC_LAYER_0);
    uint8_t *screen_mem = &m_memory[(m_memory[MEMORY_SCREEN_PHYS] << 8)];
    uint8_t *pal = &m_memory[MEMORY_PALETTES + PALTYPE_SCREEN * 16];

    for (int y = 1; y <= 128; y++)
    {
        if (y & 0x7)
        {
            uint16_t *top = output;
            uint16_t *bottom = output + 240;

            for (int x = 0; x < 128; x += 8)
            {

                uint8_t left = (*screen_mem) & 0xF;
                uint8_t right = (*screen_mem) >> 4;

                uint8_t index_left = pal[left];
                uint8_t index_right = color_pal[right];

                uint16_t c_left = m_colors[color_index(index_left)];
                uint16_t c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                *bottom++ = c_left;
                *bottom++ = c_left;
                *bottom++ = c_right;
                *bottom++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                *bottom++ = c_left;
                *bottom++ = c_left;
                *bottom++ = c_right;
                *bottom++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                *bottom++ = c_left;
                *bottom++ = c_left;
                *bottom++ = c_right;
                *bottom++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;

                *bottom++ = c_left;
                *bottom++ = c_right;
                *bottom++ = c_right;

                screen_mem++;
            }

            output += 480;
        }
        else
        {
            uint16_t *top = output;

            for (int x = 0; x < 128; x += 8)
            {

                uint8_t left = (*screen_mem) & 0xF;
                uint8_t right = (*screen_mem) >> 4;

                uint8_t index_left = pal[left];
                uint8_t index_right = pal[right];

                uint16_t c_left = m_colors[color_index(index_left)];
                uint16_t c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;
                *top++ = c_right;

                screen_mem++;

                left = (*screen_mem) & 0xF;
                right = (*screen_mem) >> 4;

                index_left = pal[left];
                index_right = pal[right];

                c_left = m_colors[color_index(index_left)];
                c_right = m_colors[color_index(index_right)];

                *top++ = c_left;
                *top++ = c_left;
                *top++ = c_right;

                screen_mem++;
            }

            output += 240;
        }
    }

    output = gdi_get_frame_buffer_addr(HW_LCDC_LAYER_0);

    for (int y = 1; y <= P8_HEIGHT; y++)
    {
        if (y & 0x7)
        {
            uint16_t *top = output;

            for (int x = 0; x < 128; x += 2)
            {
                int overlay_offset = (x >> 1) + (y - 1) * 64;
                uint8_t value = m_overlay_memory[overlay_offset];
                uint8_t left = value & 0xF;
                uint8_t right = value >> 4;

                if (left != OVERLAY_TRANSPARENT_COLOR)
                {
                    uint16_t c_left = m_colors[color_index(left)];
                    *top = c_left;
                    *(top + 1) = c_left;
                }
                top += 2;

                if (right != OVERLAY_TRANSPARENT_COLOR)
                {
                    uint16_t c_right = m_colors[color_index(right)];
                    *top = c_right;
                    *(top + 1) = c_right;
                }
                top += 2;
            }

            output += 240;
        }
    }

    gdi_display_update_async(draw_complete, NULL);
}
#elif defined(NEXTP8)
void p8_render()
{
    while (*(volatile uint8_t *) _VFRONT != vfrontreq) {
        // wait for previous flip to complete
    }
    int vback = 1 - vfrontreq;
    uint8_t *screen_mem = &m_memory[(m_memory[MEMORY_SCREEN_PHYS] << 8)];
    uint8_t *pal = &m_memory[MEMORY_PALETTES + PALTYPE_SCREEN * 16];
    memcpy((uint8_t *)_PALETTE_BASE, pal, _PALETTE_SIZE);
    memcpy((uint8_t *)_BACK_BUFFER_BASE, screen_mem, _FRAME_BUFFER_SIZE);
    static bool prev_pause_menu_showing = false;
    if (m_pause_menu_showing || prev_pause_menu_showing != m_pause_menu_showing)
        memcpy((uint8_t *)_OVERLAY_BACK_BUFFER_BASE, m_overlay_memory, MEMORY_SCREEN_SIZE);
    else
        memcpy((uint8_t *)_OVERLAY_BACK_BUFFER_BASE, m_overlay_memory, 512); // optimization: only copy first 8 rows if pause menu not showing
    prev_pause_menu_showing = m_pause_menu_showing;
    *(volatile uint8_t *) _VFRONTREQ = vfrontreq = vback;
}
#endif

#if defined(NEXTP8)
char scancode_to_name[2][256] = {
    {
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\t', '`', '\0',
        '\0', '\0', '\0', '\0', '\0', 'q', '1', '\0', '\0', '\0', 'z', 's', 'a', 'w', '2', '\0',
        '\0', 'c', 'x', 'd', 'e', '4', '3', '\0', '\0', '\0', 'v', 'f', 't', 'r', '5', '\0',
        '\0', 'n', 'b', 'h', 'g', 'y', '6', '\0', '\0', '\0', 'm', 'j', 'u', '7', '8', '\0',
        '\0', ',', 'k', 'i', 'o', '0', '9', '\0', '\0', '.', '/', 'l', ';', 'p', '-', '\0',
        '\0', '\0', '\'', '\0', '[', '=', '\0', '\0', '\0', '\0', '\r', ']', '\0', '\\', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\b', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\x1b', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\x7f', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
    },
    {
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\t', '~', '\0',
        '\0', '\0', '\0', '\0', '\0', 'Q', '!', '\0', '\0', '\0', 'Z', 'S', 'A', 'W', '@', '\0',
        '\0', 'C', 'X', 'D', 'E', '$', '#', '\0', '\0', '\0', 'V', 'F', 'T', 'R', '%', '\0',
        '\0', 'N', 'B', 'H', 'G', 'Y', '&', '\0', '\0', '\0', 'M', 'J', 'U', '\'', '(', '\0',
        '\0', '<', 'K', 'I', 'O', '-', ')', '\0', '\0', '>', '?', 'L', ':', 'P', '_', '\0',
        '\0', '\0', '"', '\0', '{', '+', '\0', '\0', '\0', '\0', '\r', '}', '\0', '|', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\b', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\x1b', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
        '\0', '\x7f', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'
    },
};

unsigned nextp8_scancode_to_sdl_scancode[NUM_SCANCODES] = {
    // 0x00-0x0F
    0, 66, 0, 62, 60, 58, 59, 69,     // F9, F5, F3, F1, F2, F12
    0, 67, 65, 63, 61, 43, 53, 0,     // F10, F8, F6, F4, TAB, `
    // 0x10-0x1F
    0, 226, 225, 0, 224, 20, 30, 0,   // L-Alt, L-Shift, L-Ctrl, Q, 1
    0, 0, 29, 22, 4, 26, 31, 0,       // Z, S, A, W, 2
    // 0x20-0x2F
    0, 6, 27, 7, 8, 33, 32, 0,        // C, X, D, E, 4, 3
    0, 44, 25, 23, 21, 34, 0, 0,      // Space, V, F, T, R, 5
    // 0x30-0x3F
    0, 17, 5, 11, 10, 28, 35, 0,      // N, B, H, G, Y, 6
    0, 0, 16, 13, 24, 36, 37, 0,      // M, J, U, 7, 8
    // 0x40-0x4F
    0, 54, 14, 12, 18, 39, 38, 0,     // comma, K, I, O, 0, 9
    0, 55, 56, 15, 51, 19, 45, 0,     // period, slash, L, semicolon, P, minus
    // 0x50-0x5F
    0, 0, 52, 0, 47, 46, 0, 0,        // apostrophe, [, =
    57, 229, 40, 48, 0, 49, 0, 0,     // CapsLock, R-Shift, Enter, ], \,
    // 0x60-0x6F
    0, 0, 0, 0, 0, 0, 42, 0,          // Backspace
    0, 89, 0, 92, 95, 0, 0, 0,        // KP-1, KP-4, KP-7
    // 0x70-0x7F
    98, 99, 90, 93, 94, 96, 41, 83,   // KP-0, KP-., KP-2, KP-5, KP-6, KP-8, Esc, NumLock
    68, 87, 91, 86, 85, 77, 71, 64,   // F11, KP-+, KP-3, KP--, KP-*, PageUp, ScrollLock, F7
    // 0x80-0x8F
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    // 0x90-0x9F
    0, 230, 0, 0, 228, 0, 0, 0,       // 0x91: R-Alt, 0x94: R-Ctrl
    0, 227, 0, 0, 0, 0, 0, 231,       // 0x9F: L-GUI, 0x9F: R-GUI
    // 0xA0-0xAF
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 266, 0, 0, 0, 0, 101,       // 0xAB: Calculator, 0xAF: Apps
    // 0xB0-0xBF
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    // 0xC0-0xCF
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 88, 0, 0, 0, 0, 0,          // 0xCA: KP-Enter
    // 0xD0-0xDF
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    // 0xE0-0xEF
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 77, 0, 80, 74, 0, 0, 0,        // 0xE9: End, 0xEB: Left, 0xEC: Home
    // 0xF0-0xFF
    73, 76, 81, 0, 79, 82, 78, 75,    // 0xF0: Insert, 0xF1: Delete, 0xF2: Down, 0xF4: Right, 0xF5: Up, 0xF6: PageDown, 0xF7: PageUp
    0, 0, 0, 0, 0, 0, 0, 0
};

#define KEY_CURSOR_LEFT 235
#define KEY_CURSOR_DOWN 242
#define KEY_CURSOR_RIGHT 244
#define KEY_CURSOR_UP 245
#define KEY_Z 26
#define KEY_X 34
#define KEY_N 49
#define KEY_M 58
#define KEY_C 33
#define KEY_V 42
#define KEY_S 27
#define KEY_D 35
#define KEY_F 43
#define KEY_E 36
#define KEY_TAB 13
#define KEY_Q 21
#define KEY_LEFT_SHIFT 18
#define KEY_A 28
#define KEY_RIGHT_SHIFT 89
#define KEY_ENTER 0x5a
#define KEY_BREAK 0x76
#define KEY_P 0x4d

#define JOY_UP      (1 << 0)
#define JOY_DOWN    (1 << 1)
#define JOY_LEFT    (1 << 2)
#define JOY_RIGHT   (1 << 3)
#define JOY_BUTTON1 (1 << 4)
#define JOY_BUTTON2 (1 << 5)

static unsigned is_down(volatile uint8_t *base, unsigned index)
{
    return base[index >> 3] & (1 << (index & 0x7));
}

static uint16_t player0_mask(volatile uint8_t *keyboard_matrix, uint8_t joy0)
{
    uint16_t mask = 0;
    if (is_down(keyboard_matrix, KEY_CURSOR_LEFT) ||
        (joy0 & JOY_LEFT))
        mask |= BUTTON_MASK_LEFT;
    if (is_down(keyboard_matrix, KEY_CURSOR_RIGHT) ||
        (joy0 & JOY_RIGHT))
        mask |= BUTTON_MASK_RIGHT;
    if (is_down(keyboard_matrix, KEY_CURSOR_UP) ||
        (joy0 & JOY_UP))
        mask |= BUTTON_MASK_UP;
    if (is_down(keyboard_matrix, KEY_CURSOR_DOWN) ||
        (joy0 & JOY_DOWN))
        mask |= BUTTON_MASK_DOWN;
    if (is_down(keyboard_matrix, KEY_Z) ||
        is_down(keyboard_matrix, KEY_N) ||
        is_down(keyboard_matrix, KEY_C) ||
        is_down(keyboard_matrix, KEY_ENTER) ||
        (joy0 & JOY_BUTTON1))
        mask |= BUTTON_MASK_ACTION1;
    if (is_down(keyboard_matrix, KEY_X) ||
        is_down(keyboard_matrix, KEY_M) ||
        is_down(keyboard_matrix, KEY_V) ||
        (joy0 & JOY_BUTTON2))
        mask |= BUTTON_MASK_ACTION2;
    if (is_down(keyboard_matrix, KEY_ENTER))
        mask |= BUTTON_MASK_PAUSE | BUTTON_MASK_RETURN;
    if (is_down(keyboard_matrix, KEY_P))
        mask |= BUTTON_MASK_PAUSE;
    if (is_down(keyboard_matrix, KEY_BREAK))
        mask |= BUTTON_MASK_ESCAPE;
    return mask;
}

static uint16_t player1_mask(volatile uint8_t *keyboard_matrix, uint8_t joy1)
{
    uint16_t mask = 0;
    if (is_down(keyboard_matrix, KEY_S) ||
        (joy1 & JOY_LEFT))
        mask |= BUTTON_MASK_LEFT;
    if (is_down(keyboard_matrix, KEY_D) ||
        (joy1 & JOY_RIGHT))
        mask |= BUTTON_MASK_RIGHT;
    if (is_down(keyboard_matrix, KEY_F) ||
        (joy1 & JOY_UP))
        mask |= BUTTON_MASK_UP;
    if (is_down(keyboard_matrix, KEY_E) ||
        (joy1 & JOY_DOWN))
        mask |= BUTTON_MASK_DOWN;
    if (is_down(keyboard_matrix, KEY_TAB) ||
        is_down(keyboard_matrix, KEY_LEFT_SHIFT) ||
        (joy1 & JOY_BUTTON1))
        mask |= BUTTON_MASK_ACTION1;
    if (is_down(keyboard_matrix, KEY_Q) ||
        is_down(keyboard_matrix, KEY_A) ||
        (joy1 & JOY_BUTTON2))
        mask |= BUTTON_MASK_ACTION2;
    return mask;
}

static uint32_t keyboard_matrix_prev[8];
#endif

void p8_update_input()
{
    bool pointer_lock = (m_memory[MEMORY_DEVKIT_MODE] & 0x4) != 0;
    if (pointer_lock != m_prev_pointer_lock) {
        m_prev_pointer_lock  = pointer_lock;
#ifdef SDL
        SDL_WM_GrabInput(pointer_lock ? SDL_GRAB_ON : SDL_GRAB_OFF);
#endif
    }

#ifdef SDL
    m_mouse_xrel = 0;
    m_mouse_yrel = 0;
    m_mouse_wheel = 0;

    SDL_Event event;
    while (SDL_PollEvent(&event))
    {
        switch (event.type)
        {
        case SDL_MOUSEMOTION:
            m_mouse_x = event.motion.x * P8_WIDTH / SCREEN_WIDTH;
            m_mouse_y = event.motion.y * P8_HEIGHT / SCREEN_HEIGHT;
            m_mouse_xrel += event.motion.xrel * P8_WIDTH / SCREEN_WIDTH;
            m_mouse_yrel += event.motion.yrel * P8_HEIGHT / SCREEN_HEIGHT;
            break;
        case SDL_MOUSEBUTTONDOWN:
            if (event.button.button == 1) {
                m_mouse_buttons |= 0x1;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_ACTION1, true);
            } else if (event.button.button == 3) {
                m_mouse_buttons |= 0x2;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_ACTION2, true);
            } else if (event.button.button == 2) {
                m_mouse_buttons |= 0x4;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_PAUSE, true);
            } else if (event.button.button == 4) {
                m_mouse_wheel += 1;
            } else if (event.button.button == 5) {
                m_mouse_wheel -= 1;
            }
            break;
        case SDL_MOUSEBUTTONUP:
            if (event.button.button == 1) {
                m_mouse_buttons &= ~0x1;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_ACTION1, false);
            } else if (event.button.button == 3) {
                m_mouse_buttons &= ~0x2;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_ACTION2, false);
            } else if (event.button.button == 2) {
                m_mouse_buttons &= ~0x4;
                if (m_memory[MEMORY_DEVKIT_MODE] & 0x2)
                    update_buttons(0, BUTTON_PAUSE, false);
            }
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case INPUT_LEFT:
                update_buttons(0, BUTTON_LEFT, true);
                break;
            case INPUT_RIGHT:
                update_buttons(0, BUTTON_RIGHT, true);
                break;
            case INPUT_UP:
                update_buttons(0, BUTTON_UP, true);
                break;
            case INPUT_DOWN:
                update_buttons(0, BUTTON_DOWN, true);
                break;
            case INPUT_ACTION1:
                update_buttons(0, BUTTON_ACTION1, true);
                break;
            case INPUT_ACTION2:
                update_buttons(0, BUTTON_ACTION2, true);
                break;
            case INPUT_ESCAPE:
                update_buttons(0, BUTTON_ESCAPE, true);
                break;
            case SDLK_RETURN:
                update_buttons(0, BUTTON_PAUSE, true);
                update_buttons(0, BUTTON_RETURN, true);
                break;
            case SDLK_p:
                update_buttons(0, BUTTON_PAUSE, true);
                break;
            default:
                break;
            }
            if (event.key.keysym.scancode < NUM_SCANCODES)
                m_scancodes[event.key.keysym.scancode] = true;
            m_keypress = (event.key.keysym.sym < 256) ? event.key.keysym.sym : 0;
            break;
        case SDL_KEYUP:
            switch (event.key.keysym.sym)
            {
            case INPUT_LEFT:
                update_buttons(0, BUTTON_LEFT, false);
                break;
            case INPUT_RIGHT:
                update_buttons(0, BUTTON_RIGHT, false);
                break;
            case INPUT_UP:
                update_buttons(0, BUTTON_UP, false);
                break;
            case INPUT_DOWN:
                update_buttons(0, BUTTON_DOWN, false);
                break;
            case INPUT_ACTION1:
                update_buttons(0, BUTTON_ACTION1, false);
                break;
            case INPUT_ACTION2:
                update_buttons(0, BUTTON_ACTION2, false);
                break;
            case SDLK_RETURN:
                update_buttons(0, BUTTON_PAUSE, false);
                update_buttons(0, BUTTON_RETURN, false);
                break;
            case SDLK_p:
                update_buttons(0, BUTTON_PAUSE, false);
                break;
            case INPUT_ESCAPE:
                update_buttons(0, BUTTON_ESCAPE, false);
                break;
            default:
                break;
            }
            if (event.key.keysym.scancode < NUM_SCANCODES)
                m_scancodes[event.key.keysym.scancode] = false;
            break;
        case SDL_QUIT:
            p8_abort();
            break;
        default:
            break;
        }
    }
#elif defined(OS_FREERTOS)
    uint16_t mask = 0;

    if (gamepad & AXIS_L_LEFT)
        mask |= BUTTON_MASK_LEFT;
    if (gamepad & AXIS_L_RIGHT)
        mask |= BUTTON_MASK_RIGHT;
    if (gamepad & AXIS_L_UP)
        mask |= BUTTON_MASK_UP;
    if (gamepad & AXIS_L_DOWN)
        mask |= BUTTON_MASK_DOWN;
    if (gamepad & AXIS_L_TRIGGER)
        mask |= BUTTON_MASK_ACTION1;
    if (gamepad & AXIS_R_LEFT)
        mask |= BUTTON_MASK_LEFT;
    if (gamepad & AXIS_R_RIGHT)
        mask |= BUTTON_MASK_RIGHT;
    if (gamepad & AXIS_R_UP)
        mask |= BUTTON_MASK_UP;
    if (gamepad & AXIS_R_DOWN)
        mask |= BUTTON_MASK_DOWN;
    if (gamepad & AXIS_R_TRIGGER)
        mask |= BUTTON_MASK_ACTION2;
    if (gamepad & DPAD_UP)
        mask |= BUTTON_MASK_UP;
    if (gamepad & DPAD_RIGHT)
        mask |= BUTTON_MASK_RIGHT;
    if (gamepad & DPAD_DOWN)
        mask |= BUTTON_MASK_DOWN;
    if (gamepad & DPAD_LEFT)
        mask |= BUTTON_MASK_LEFT;
    if (gamepad & BUTTON_1)
        mask |= BUTTON_MASK_ACTION1;
    if (gamepad & BUTTON_2)
        mask |= BUTTON_MASK_ACTION2;

    m_buttons[0] = mask;

#elif defined(NEXTP8)
    volatile uint8_t *keyboard_matrix = (volatile uint8_t *) _KEYBOARD_MATRIX;
    volatile uint8_t *keyboard_matrix_latched = (volatile uint8_t *) _KEYBOARD_MATRIX_LATCHED;
    volatile uint8_t *joy0_latched_ptr = (volatile uint8_t *) _JOYSTICK0_LATCHED;
    volatile uint8_t *joy1_latched_ptr = (volatile uint8_t *) _JOYSTICK1_LATCHED;

    uint8_t joy0 = *(volatile uint8_t *) _JOYSTICK0;
    uint8_t joy1 = *(volatile uint8_t *) _JOYSTICK1;
    uint8_t joy0_latched = *joy0_latched_ptr;
    uint8_t joy1_latched = *joy1_latched_ptr;

    // Set current button state from unlatched inputs
    m_buttons[0] = player0_mask(keyboard_matrix, joy0);
    m_memory[MEMORY_BUTTON_STATE] = m_buttons[0] & 0xff;

    // Set button press state from latched inputs
    m_buttonsp[0] = player0_mask(keyboard_matrix_latched, joy0_latched);

    // Clear joystick latched bits for player 0
    *joy0_latched_ptr = 255;

    // Set current button state from unlatched inputs
    m_buttons[1] = player1_mask(keyboard_matrix, joy1);
    m_memory[MEMORY_BUTTON_STATE + 1] = m_buttons[1] & 0xff;

    // Set button press state from latched inputs
    m_buttonsp[1] = player1_mask(keyboard_matrix_latched, joy1_latched);

    // Clear joystick latched bits for player 1
    *joy1_latched_ptr = 255;

    // Clear all keyboard latched bits
    memset((void *)keyboard_matrix_latched, 0xff, 32);

    bool need_update = false;
    volatile uint32_t *keyboard_matrix32 = (volatile  uint32_t *) keyboard_matrix;
    for (unsigned i = 0; i < 8; ++i) {
        if (keyboard_matrix32[i] != keyboard_matrix_prev[i])
            need_update = true;
        keyboard_matrix_prev[i] = keyboard_matrix32[i];
    }
    if (need_update) {
        bool shifted = is_down(keyboard_matrix, KEY_LEFT_SHIFT) ||
                       is_down(keyboard_matrix, KEY_RIGHT_SHIFT);
        for (unsigned i=0;i<256;++i) {
            bool down = is_down(keyboard_matrix, i);
            if (down)
                m_keypress = scancode_to_name[shifted?1:0][i];
            m_scancodes[nextp8_scancode_to_sdl_scancode[i]] = down;
        }
    }

    int16_t mouse_x_accum = *(volatile int16_t *) _MOUSE_X;
    int16_t mouse_y_accum = *(volatile int16_t *) _MOUSE_Y;
    int16_t mouse_z_accum = *(volatile int16_t *) _MOUSE_Z;
    m_mouse_buttons = *(volatile uint8_t *) _MOUSE_BUTTONS;

    // Handle wrap-around of signed 16-bit accumulators
    m_mouse_xrel = (int16_t)(mouse_x_accum - mouse_x_accum_prev);
    m_mouse_yrel = (int16_t)(mouse_y_accum - mouse_y_accum_prev);
    m_mouse_wheel = (int16_t)(mouse_z_accum - mouse_z_accum_prev);

    mouse_x4 += m_mouse_xrel;
    mouse_y4 += m_mouse_yrel;
    if (mouse_x4 < 0) mouse_x4 = 0;
    if (mouse_x4 >= P8_WIDTH * 4) mouse_x4 = P8_WIDTH * 4 - 1;
    if (mouse_y4 < 0) mouse_y4 = 0;
    if (mouse_y4 >= P8_HEIGHT * 4) mouse_y4 = P8_HEIGHT * 4 - 1;
    m_mouse_x = mouse_x4 / 4;
    m_mouse_y = mouse_y4 / 4;

    mouse_x_accum_prev = mouse_x_accum;
    mouse_y_accum_prev = mouse_y_accum;
    mouse_z_accum_prev = mouse_z_accum;

    if (m_memory[MEMORY_DEVKIT_MODE] & 0x2) {
        m_buttons[0] |= (m_mouse_buttons & 0x7) << 4;

        volatile uint8_t mouse_buttons_latched = *(volatile uint8_t *) _MOUSE_BUTTONS_LATCHED;
        m_buttonsp[0] |= (mouse_buttons_latched & 0x7) << 4;
        *(volatile uint8_t *) _MOUSE_BUTTONS_LATCHED = 0xff;
    }
#endif

    uint8_t delay = m_memory[MEMORY_AUTO_REPEAT_DELAY];
    if (delay == 0)
        delay = DEFAULT_AUTO_REPEAT_DELAY;
    uint8_t interval = m_memory[MEMORY_AUTO_REPEAT_INTERVAL];
    if (interval == 0)
        interval = DEFAULT_AUTO_REPEAT_INTERVAL;
    for (unsigned p=0;p<PLAYER_COUNT;++p) {
#ifndef NEXTP8
        m_buttonsp[p] = 0;
#endif
        for (unsigned i=0;i<BUTTON_INTERNAL_COUNT;++i) {
            if (m_buttons[p] & (1 << i)) {
                if (m_button_down_time[p][i] == UINT_MAX) {
                    // ignore buttons pressed at startup
                } else if (!m_button_down_time[p][i]) {
                    m_button_down_time[p][i] = m_frames;
#ifndef NEXTP8
                    m_buttonsp[p] |= 1 << i;
#endif
                } else if (i < BUTTON_REPEAT_COUNT) {
                    if (delay != 255 && !(m_button_first_repeat[p] & (1 << i)) && m_frames - m_button_down_time[p][i] >= delay) {
                        m_button_down_time[p][i] = m_frames;
                        m_button_first_repeat[p] |= 1 << i;
                        m_buttonsp[p] |= 1 << i;
                    } else if ((m_button_first_repeat[p] & (1 << i)) && m_frames - m_button_down_time[p][i] >= interval) {
                        m_button_down_time[p][i] = m_frames;
                        m_buttonsp[p] |= 1 << i;
                    }
                }
            } else  {
                if (m_button_down_time[p][i]) {
                    m_button_down_time[p][i] = 0;
                    m_button_first_repeat[p] &= ~(1 << i);
                }
            }
        }
    }

    if ((m_buttons[0] & BUTTON_MASK_ESCAPE) != 0)
        p8_abort();

    if (!m_pause_menu_showing) {
        if ((m_buttonsp[0] & BUTTON_MASK_PAUSE) != 0) {
            p8_show_pause_menu();
        }
    }
}

static void p8_post_flip(void)
{
    p8_flush_cartdata();
    p8_update_input();
    m_frames++;
}

void p8_flip()
{
    p8_render();

    unsigned elapsed_time = p8_elapsed_time();
    const unsigned target_frame_time = 1000 / m_fps;
    int sleep_time = target_frame_time - elapsed_time;
    if (sleep_time < 0)
        sleep_time = 0;
    m_actual_fps = 1000 / (elapsed_time + sleep_time);

    if (sleep_time > 0)
        p8_sleep(sleep_time);

    m_start_time = p8_clock();

    p8_post_flip();
}

static void p8_main_loop()
{
    const int target_frame_time = 1000 / m_fps;
    int time_debt = 0;
    unsigned updates_since_last_flip = 0;

    for (;;)
    {
        lua_update();
        updates_since_last_flip++;

        unsigned elapsed = p8_elapsed_time();

        time_debt += elapsed;

        if (time_debt < target_frame_time || updates_since_last_flip >= m_fps) {
            lua_draw();
            time_debt += p8_elapsed_time() - elapsed;

            p8_flip();

            if (updates_since_last_flip >= m_fps) {
                time_debt = 0;
            } else {
                time_debt -= target_frame_time;
                if (time_debt < -target_frame_time) time_debt = -target_frame_time;
            }

            updates_since_last_flip = 0;
        } else {
            p8_post_flip();

            time_debt -= target_frame_time;
        }
    }
}

unsigned p8_elapsed_time(void)
{
    p8_clock_t now = p8_clock();
    unsigned elapsed_time;
    if (m_start_time == 0)
        elapsed_time = 0;
    else
        elapsed_time = p8_clock_ms(p8_clock_delta(m_start_time, now));
    return elapsed_time;
}

void p8_pump_events(void)
{
#if defined(SDL)
    SDL_PumpEvents();

    SDL_Event event;
    while (SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_QUITMASK | SDL_KEYDOWNMASK) > 0) {
        if (event.type == SDL_QUIT)
            p8_abort();
        else if (event.type == SDL_KEYDOWN) {
            if ((event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_p) &&
                (m_buttons[0] & BUTTON_MASK_PAUSE) == 0) {
                p8_show_pause_menu();
            } else if (event.key.keysym.sym == INPUT_ESCAPE && (m_buttons[0] & BUTTON_MASK_ESCAPE) == 0) {
                p8_abort();
            }
        }
    }
#elif defined(NEXTP8)
    volatile uint8_t *keyboard_matrix = (volatile uint8_t *) _KEYBOARD_MATRIX;
    bool escape_down = is_down(keyboard_matrix, KEY_BREAK);
    if (escape_down && (m_buttons[0] & BUTTON_MASK_ESCAPE) == 0)
        p8_abort();

    bool enter_down = is_down(keyboard_matrix, KEY_ENTER);
    bool p_down = is_down(keyboard_matrix, KEY_P);
    if ((enter_down || p_down) && (m_buttons[0] & BUTTON_MASK_PAUSE) == 0)
        p8_show_pause_menu();
#endif
}

void p8_seed_rng_state(uint32_t seed)
{
    uint32_t hi, lo;

    if (seed == 0) {
        hi = 0x60009755;
        lo = 0xdeadbeef;
    } else {
        seed &= 0x7fffffff;

        uint32_t seed_fixed = seed << 16;
        hi = seed_fixed ^ 0xbead29ba;
        lo = seed_fixed;
    }

    for (int i = 0; i < 32; i++) {
        hi = (hi << 16) | (hi >> 16);
        hi += lo;
        lo += hi;
    }

    m_memory[MEMORY_RNG_STATE] = hi & 0xFF;
    m_memory[MEMORY_RNG_STATE + 1] = (hi >> 8) & 0xFF;
    m_memory[MEMORY_RNG_STATE + 2] = (hi >> 16) & 0xFF;
    m_memory[MEMORY_RNG_STATE + 3] = (hi >> 24) & 0xFF;
    m_memory[MEMORY_RNG_STATE + 4] = lo & 0xFF;
    m_memory[MEMORY_RNG_STATE + 5] = (lo >> 8) & 0xFF;
    m_memory[MEMORY_RNG_STATE + 6] = (lo >> 16) & 0xFF;
    m_memory[MEMORY_RNG_STATE + 7] = (lo >> 24) & 0xFF;
}

void p8_reset(void)
{
    memset(m_memory + MEMORY_DRAWSTATE, 0, MEMORY_DRAWSTATE_SIZE);
    memset(m_memory + MEMORY_HARDWARESTATE, 0, MEMORY_HARDWARESTATE_SIZE);
    m_memory[MEMORY_SCREEN_PHYS] = 0x60;
    m_memory[MEMORY_MAP_START] = 0x20;
    m_memory[MEMORY_MAP_WIDTH] = 128;
    pencolor_set(6);
    reset_color();
    clip_set(0, 0, P8_WIDTH, P8_HEIGHT);
    p8_seed_rng_state(time(NULL));
}

void __attribute__ ((noreturn)) p8_abort()
{
    longjmp(jmpbuf_restart, 1);
}

void __attribute__ ((noreturn)) p8_restart()
{
    restart = true;
    p8_abort();
}

char *p8_resolve_relative_path(const char *filename)
{
    if (filename[0] == '/' || filename[1] == ':')
        return strdup(filename);

    if (!current_cart_dir)
        return strdup(filename);

    size_t len = strlen(current_cart_dir) + strlen(filename) + 2;
    char *resolved_path = malloc(len);
    if (resolved_path)
        snprintf(resolved_path, len, "%s/%s", current_cart_dir, filename);
    return resolved_path;
}

void __attribute__ ((noreturn)) p8_load_new(const char *filename, const char *param)
{
    assert(m_load_available);

    if (load_filename) {
#ifdef OS_FREERTOS
        rh_free(load_filename);
#else
        free(load_filename);
#endif
    }
    if (load_param) {
#ifdef OS_FREERTOS
        rh_free(load_param);
#else
        free(load_param);
#endif
    }

    load_filename = strdup(filename);
    load_param = param ? strdup(param) : NULL;
    load_requested = true;

    longjmp(jmpbuf_load, 1);
}

void p8_set_skip_compat_check(bool skip)
{
    skip_compat_check = skip;
}

void p8_set_skip_main_loop_if_no_callbacks(bool skip)
{
    skip_main_loop_if_no_callbacks = skip;
}

bool p8_open_cartdata(const char *id)
{
    if (cartdata)
        return false;
    int ret = MKDIR(CARTDATA_PATH);
    if (ret == -1 && errno != EEXIST) {
        return false;
    }
    char *path = alloca(strlen(CARTDATA_PATH) + 1 + strlen(id) + 1);
    sprintf(path, "%s/%s", CARTDATA_PATH, id);
    cartdata = fopen(path, "r+b");
    if (!cartdata) {
        cartdata = fopen(path, "w+b");
        if (!cartdata) {
            return false;
        }
    }
    fseek(cartdata, 0, SEEK_SET);
    uint8_t *dst = m_memory + MEMORY_CARTDATA;
    size_t n = fread(dst, 1, 0x100, cartdata);
    if (n < 0x100) {
        memset(dst + n, 0, 0x100 - n);
    }
    return true;
}

void p8_flush_cartdata(void)
{
    if (cartdata && cartdata_needs_flush) {
        cartdata_needs_flush = false;
        fseek(cartdata, 0, SEEK_SET);
        fwrite(m_memory + MEMORY_CARTDATA, 0x100, 1, cartdata);
        fflush(cartdata);
    }
}

void p8_delayed_flush_cartdata(void)
{
    cartdata_needs_flush = true;
}

void p8_close_cartdata(void)
{
    if (cartdata) {
        p8_flush_cartdata();
        fclose(cartdata);
        cartdata = NULL;
    }
}

static void p8_show_compatibility_error(int severity)
{
    m_pause_menu_showing = true;
    p8_reset();
    clear_screen(0);
    draw_rect(10, 51, 118, 78, 7, 0);
    if (severity <= COMPAT_SOME) {
        draw_simple_text("this cart may not be", 24, 55, 7);
        draw_simple_text("fully compatible with", 22, 62, 7);
        draw_simple_text(PROGNAME, 64-strlen(PROGNAME)*GLYPH_WIDTH/2, 69, 7);
    } else {
        draw_simple_text("this cart is not", 32, 55, 7);
        draw_simple_text("compatible with", 34, 62, 7);
        draw_simple_text(PROGNAME, 64-strlen(PROGNAME)*GLYPH_WIDTH/2, 69, 7);
    }
    p8_flip();
    do {
        p8_update_input();
    } while ((m_buttons[0] & (BUTTON_MASK_ACTION1 | BUTTON_MASK_RETURN)) == 0);
    clear_screen(0);
    m_button_down_time[0][BUTTON_ACTION1] = UINT_MAX;
    m_pause_menu_showing = false;
}

void p8_show_disk_icon(bool show)
{
    if (show)
        overlay_draw_icon(disk_icon, P8_WIDTH - 8, 0);
    else
        overlay_draw_rectfill(P8_WIDTH - 8, 0, P8_WIDTH-1, 7, OVERLAY_TRANSPARENT_COLOR);
    p8_flip();
}
